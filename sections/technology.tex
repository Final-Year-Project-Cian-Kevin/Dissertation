\chapter{Technology Review}
This chapter will cover the technical side of our project, by looking back on the technologies that made up the final revision of the project. We will explain the different technologies we added and how they were implemented through the project. We will look over the web stack we used and the technologies we added in order to create a more robust and useful social media site. We will go over why we used the given technologies and the benefits we saw in them over others.

% ========================== Frame Work  ========================== 
\section{MEAN STACK/Framework}
The mean stack is intended to provide a simple and fun starting point for cloud native full-stack JavaScript applications. MEAN is a set of Open Source components that together, provide an end-to-end framework for building dynamic web applications; starting from the top (code running in the browser) to the bottom (database). 

The stack is made up of:

\begin{itemize}
\item MongoDB
\item ExpressJS
\item Angular
\item Node.js
\end{itemize}

Early in development when we were brainstorming, we decided to do a full stack development. The next step after this decision was to figure out how to carry out this task. We looked into full development stacks such as the MERN stack (MongoDB, ExpressJS, React, Node.js), MEAN stack (MongoDB, ExpressJS, Angular, Node.js) or doing a Java-based development stack (Spring boot, Angular, MongoDB). After lots of discussion and input from supervisors, we decided to not go with the Java-based development stack. We then took a deep dive into the difference between the MEAN/MERN stack to decide what route we wanted to take and start development as soon as possible. After looking into React JSX vs Angular HTML templating and experimenting with the two stacks we finally decided that the MEAN stack was more inline in what we wanted to learn.

Once we knew what stack we were using and how to use it in a basic form from our prototyping stage, we moved onto breaking the stack down to each component and getting to know each component better, so when full development starts we would have a better understand how the entire stack operates and interacts with each component. This gave us a greater understanding of how each component operated and allowed us to plan out how each component would operate from top to bottom. 

\subsection{MongoDB}
You may know what MySQL and other relational databases are. MySQL is analogous to a spreadsheet, it has name columns and rows of rows of data. Every database "tool" shows the data as a spreadsheet (Microsoft Access). Data can be linked through special functions such as a "JOIN" mechanism to allow the user to built meta spreadsheets. 

MongoDB is a database and not a database tool (Mongo Compass), instead of a spreadsheet like MySQL it is more like a folder of documents. The contents of the "folders" are not checked to see if the new file differs from the current file format. This sounds like an inefficient system but all these folders are called collections in MongoDB. The collections are usually grouped by how the user would group MySQL tables. While MongoDB can contain keys like MySQL there is no built-in functionality in order to join documents together in order to retrieve related data in another collection.

Databases are classified into two categories of SQL and NoSQL. MySQL is an example of an SQL database, and MongoDB is an example of a NoSQL database. MongoDB is very reliable as its very hands off and gives the user the responsibility for how data is saved and read. If a user adds another entry into the collection that doesn't match the other entries MongoDB doesn't inform the user that the data is not in the correct format as collections do not have definitions and leave that responsibility to the user. The same goes for joining two collections together. The joining is left up to the user on how they carry that out, usually, the user would create an ID which is present in both collections in order to 'join' them together.

MongoDB is so hands off about how users read and write to the database it stops the frequently used attack on SQL databases called SQL injection. SQL injection occurs when the user directly interacts with the database which allows them to manipulate their input to test the database. MongoDB doesn't have this problem as its hands off the reading data to the user to the point where a search for that data will include the statement but nor process the statement as such.

\subsection{ExpressJS}
ExpressJS is a minimalistic web framework built for Node.js that waits for the browser to connect so the server can send process the request and send back the relevant form (JSON, HTML, Raw Text, ETC...). Without ExpressJS the user must handle creating a server, handling routing all manually.

ExpressJS relies on APIs made available by Node.js. ExpressJS cannot exist without Node.js. ExpressJS is a thin layer over Node.js which makes developing servers and routes much easier. ExpressJS's main feature that makes it enticing to developers is how it serves dynamic content (Content that changes based on user requests). 

ExpressJS also has the capability to server components from frameworks such as Angular, Ember and React and process requests made by those components to update their content. ExpressJS makes Node.js development easier, especially when creating APIs that front-end apps use. Express makes it easier to unify the front-end apps and the API.

ExpressJS was an easy pick for the project as it easily integrates Node.js and rapidly decreased the time it would take to get the server side API up and running.

\subsection{Angular}
Angular is a front-end web framework built on top of JavaScript, it is used to develop single-page web applications. Single-page web frameworks (Angular, React, Ember) are websites which have all the functionality of a multiple page website without having the need to refresh the browser when moving from page to page. Single-page web development frameworks have become increasingly popular in the last few years due to how reactive they are. Pages react very fast and fluidly making user interaction with the website more positive than refreshing when moving to another page on the same website. 

Angular has been around since 2010 with the release of AngularJS. Later version came out and greatly improved upon the idea with Angular 2+ or Angular v2. This version would be improved upon and maintained by Google with the latest release being Angular 7 in late 2018. Despite angular being around for nearly 10 years, it has only been in the last few years where it has come into its own and seen real competition from other single-page frameworks such as React and Ember.

We chose Angular because of its integration with Node.js/ExpressJS which allowed us to get prototypes for testing the MEAN stack up and running very quickly and let us play around with the different functions it offered as part of its component-based setup. Within a week we had the entire MEAN stack in a functional state where Angular was served with Node.js/ExpressJS and then send and received data from the API served by the Node.js/ExpressJS server.

\subsection{Node.js}
Node.js is a cross-platform JavaScript run-time environment that allows developers to run JavaScript outside the browser. This framework is a huge deal for JavaScript. Node.js allows developers to perform actions with JavaScript on the developer's local machine like they would with other programming languages. What makes Node.js so beloved by developers is the built-in functionality of Node.js. Node.js has built-in HTTP function to allow Node.js to run HTTP actions all within the environment. This built-in HTTP functionality has made Node.js extremely popular and given the rise to isomorphic web applications and due to the fact that Node.js can run as a server back-end using JavaScript and have JavaScript on the front-end meaning there is the opportunity for the two to share code between them reducing testing and maintenance.

Node.js is a great framework due when paired with a front-end framework such as Angular, and a database such as MongoDB. When using a setup like this the entire web stack is a JavaScript based and allows the user to easily manipulate data from top to bottom.

The reason we picked Node.js is because of its ease of use and how rapidly we could get a working HTTP server up and running. Node.js also made a lot of sense when paired with Angular which was the front-end framework we picked. Node.js makes developing HTTP servers easy, which allowed us to spend more time on setting up other features such as user authentication and the Reddit API. 

\subsubsection{Node Modules}
Node.js allows developers to develop and use packages which provide the developer with more functionality.

\begin{figure}[!htb]
  \includegraphics[width=\linewidth]{img/moduleCount.PNG}
  \caption{NPM Package Count}
  \label{fig:NPM}
\end{figure}

NPM is the worldâ€™s largest software registry. NPM allows developers access to lots of packages for all sorts of development such as packages for Node.js, Angular, MongoDB and even developing Alexa skills. NPM allows developers to upload custom packages that they have developed and give access to other developers to use it in their system.

Node modules is a powerful resource with lots of packages that adds great functionality to the developer's project such as user authentication with Passport.js.


% ========================== DEPLOYMENT  ========================== 
\section{Deployment}
For code deployments we looked at numerous cloud service provides to figure out what would be the best service to take use of for our project. We looked at Google Cloud, Heroku and AWS as the cloud service providers. Although these are only a fraction of the cloud service providers online, we found they were received very well by our supervisors as a way of deployment. 

We ruled out Google cloud after lots of debate on how to move forward with deployment. The reason to remove Google Cloud first was we felt that we wanted to get a greater understanding of a different cloud service provider as we already had experience with Google Cloud. After ruling our Google Cloud we were left with Heroku and AWS. After researching more into both options and figuring out what would better with our project we decided to go with AWS because of AWS's Elastic Beanstalk. AWS Elastic Beanstalk is a system provided by AWS for deploying and scaling web applications and services developed with Java, .NET, PHP, Node.js, Python, Ruby, Go, and Docker on familiar servers.  Because of AWS's Elastic Beanstalk and us using the MEAN stack, it was an easy way to deploy our project, and an easier way to expand the project if we wanted to go commercial with the website.

% ========================== API  ========================== 
\section{Node API}
Where did we get site data?

\subsection{Reddit API}
why reddit ?

What was our aim in styling? research of other social platforms.

% ========================== Styling and UI  ========================== 
\section{Styling and UI}
What was our aim in styling? research of other social platforms.

\subsection{CSS}
why?
\subsection{Bootstrap}
why?
\subsection{Angular Material}
why?

% ========================== Other Technology's  ========================== 
\section{Other Technology's/dev environment}
Other technology used
\subsection{Visual Studio Code}
\subsection{Browsers}
chrome firefox
\subsection{Swagger}
\subsection{Latex}



